Name: Andy Chen
Email: achen81@ucsc.edu
Student ID: 1537306
Lab Assignment: Lab 5: Decimal to Binary Converter
Section Number: 01D

1. If the user input a number that is too large to fit in a 32-bit 2SC number, the number will be converted into a negative number. For example, if the user inputs 2147483650, which, is a number that is too large to fit in a 32-bit 2SC number, the conversion from decimal to binary will result in a carry out which will put a 1 on the MSB, and as a result, will define the result as a negative. So 2147483650 converted into binary will be 10000…00010 which is -2147483646 in decimal.

2.If the user inputs a number that is too small to fit in a 32-bit 2SC number, the number, which is converted from decimal to binary, will be seen as a positive number. So for example, if the user inputs -2147483650, which, is a number that is too small to fit in a 32-bit 2SC number, the result will be 2147483646 or 01111…11110. This result occurs because as you convert -2147483650 into binary, a carryout will occur which will be placed in the 33rd bit, and, because the carryout is in the 33rd bit, it cannot be stored in the 32nd bit, thus, the “1” that determines if the number is negative is omitted and the result will be treated as a positive number.

3.The difference between the “mult” and the “multu” instructions is that multu only deals with unsigned integers and “mult” can deal with signed integers. So for example, if the user would want to multiply a certain number with a negative number, “mult” will be used as it can multiply signed integers and store it, however, “multu” is not capable of doing that and can only work on unsigned integers and store unsigned numbers. For this program, I used “multu” because I am only multiplying two unsigned integers together and store it into a register. I then use that register to do 2SC if the user’s input is negative, so, my program does not need to be multiplied by a negative number, thus, I decided to use “multu”.

4. For writing a binary-to-decimal converter, I would first load $a1 into $s1, and make a loop called “Go_to_LSB”. I then would lb $s1 into $t1, subtract $t1 by 0, and if it is equal to 0, I would go to the branch “Near_End”. I then increment $s1 by 1 and branch back to “Go_to_LSB. At the branch “Near_End”, I would decrement $s1 by 1 and end the loop. I would then continue to write the code through making a branch called “loop_start”, create a counter $t0 that starts at 0. I then check if the LSB is equal to 1 or 0 by subtracting it with ASCII value of 0(0), and if it is 0, it will branch to “Increment_Counter”, else, the register $s0, which will contain the calculation, will be equal to itself plus 2^$t0. Then $t0 will increment itself by 1, $s1 will decrement itself to point to the next left bit. I then put a conditional where I would say if $s0 - 48 equals to 1 or 0, I would branch back to “loop_start”, else, the program will continue down and exit the loop, and, the program will then end. Just like the DBC, the BDC relies ASCII values to convert a string into an actual number. In addition, both methods relies on going through each bit by bit to determine what string it is in order to convert that string into binary or decimal. However, the difference between BDC and DBC relies on their unique methods. For BDC, the method consists of multiplying by 2^n where n represents the bit that a register is pointing at and add that to the sum of $s0, whereas, the DBC method consists of checking if the next bit is a digit, and if it is, the first bit will be multiplied by 10 then added with the second bit, store it into $s0, and the program will go back to the beginning of the loop. 