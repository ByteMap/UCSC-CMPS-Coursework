Name: Andy Chen
Email: achen81@ucsc.edu
Student ID: 1537306
Lab Assignment: Lab 6: Vigenere Cipher
Section Number: 01D


In this lab, I learned how to call other methods (jump and link) within a method. I also learned that before ending the method that was called, I would need to reset the registers that would not be overwritten in other ways in the subroutine that called that subroutine. Without resetting those registers, the program might do something that could result in something that I did not want, for example, having a different value than expected in the register that contained the key for the cipher. I had initially ran into this problem and had my program either not print out anything in the EncryptString subroutine or print some random unexpected string. In order to solve this issue, I found out that some registers were not being reset so I had to add code at the end of the subroutine before returning to the calling code that would set those registers to 0, which, had worked out perfectly. A plan that did not work was that when I was trying to make code that detects if the character was not valid, I had originally thought about using 3 conditionals to simply detect the special characters, but I had soon found out that I needed 4 conditionals where the the register not only check if the value is greater than 90 and less than 97, but also less than 97 and greater than 90 in order to work. If I had that one condition, I figured out that the program can detect that the value is less than 97 but not greater than 90 and continue through the program and cause some anomaly, which, was actually surprising as I thought that the logic of using that one branch could work like a 2 in 1 instead of having two separate distinct functions.

1. Additional test code that I wrote was testDecryptChar and testDecryptString. The reason why I wrote them was to test if DecryptChar was functioning properly as well as DecryptString, and without it, I would not have an efficient way of properly debugging the two subroutines. Fortunately, the two additional test methods had worked as they were very similar to the test methods of EncryptChar and EncryptString so it made it very easy to write the test methods for DecryptChar and DecryptString.

2.In a case where you attempt encryption with a keystroking that has illegal characters, you would most likely end up with random results. The reason for this is because I had wrote this program accordingly to what the PDF wants, and, the PDF states that “The keystroking will only contain uppercase characters in the alphabet” and I had programmed the subroutines to only encrypt and decrypt with uppercase characters in the alphabet as the key. If an illegal character was read as a key, the program would treat it as an uppercase letter and subtract it by 65, which, would result in something unexpected at the end of the subroutine.

3. I would call a recursive subroutine through first creating a register that points to the memory location of where the data that will be used in the recursion is located, then make a label for the subroutine, then push all the data onto a stack before calling itself  again and again until the condition to end the recursion is met. When the condition to end the recursion is met, I would then make a loop where the program will continue popping the data that it had pushed when it was calling itself until it reached the register that is pointing to the memory address where the subroutine first started.

4. To pass more than 4 arguments into a subroutine, I can simply push those arguments into a stack in order to store them then pop them when I need to use them. For example, if I had 8 arguments to pass into a subroutine but I only have 4 $a registers, I can simply push those 8 arguments into an $a register and within that subroutine, if I need to use an argument, I can pop a byte, store it into a t register, and continue that process until there are no more data stored into an $a register, and continue through the subroutine.