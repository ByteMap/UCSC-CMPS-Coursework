Name: Andy Chen
Email: achen81@ucsc.edu
Student ID: 1537306
Lab Assignment: Lab 2: Ripple Memory With Adder
Section Number: 01D

1. From this lab, I learned not only how to build a six-bit adder as well as a six-bit inverter, but also how perfectly each of the components: Register, Adder, and Inverter come hand in hand together. For example, I understood and was fascinated at how the inverter took in the two inputs:AddSub and Keypad, then output its bit number and pass it to the adder where it takes the memory from the register, the output of the inverter, and the AddSub switch as its first carry-in input then output the sum to the register where it will store and show the sum. What was surprising in this lab was the complexity of the inverter. At first I thought that it would be the easiest component since all it does is flip the bits and add a one, but I soon noticed that it wasn’t as simple as it looked. I had tried just using inverter gates to flip the bits, but that did not work out as I did not have anything to add the one. Furthermore that method was totally invalid because there will be a chance where I wont flip the bits, but I will have to because of my logic. So after going to a couple of labs and playing around with my logic, I had finally designed the inverter where it takes two inputs: Keypad and AddSub, where AddSub is the “Add the one” part which will be implemented in the Adders. If AddSub is set to subtract, Keypad will be sent through the inverter gate then to the AND gate with AddSub and passed through the OR gate where the other input for the OR gate will be the inverted AddSub ANDED with original Keypad. This way works perfectly as if the bit for the keypad is 0 and AddSub is Subtracting, then then both inputs will be (1,1) in the AND gate making the output 1, and if Keypad is 0, it will return (1,0) in AND gate which returns a 0. If AddSub is flipped to Add, then AddSub will be put through the inverter (AddSub is put through the inverter since it is run into an AND gate) along with the original bit, so, if  Keypad is 1, AND would be (1,1), making OR always return a 1, and, if Keypad is 0, And would be (1,0) returning a 0 from OR gate.

2. The issues I had building the circuit was creating the figuring out the inputs and outputs of each component as well as figuring out how to create the Adder and Inverter. The Inverter took some trial and error and playing around with logic to figure out. The Adder only needed a truth table for me to figure out what I want. The main issue that I had was figuring out what each of the components’ input and output should be, and, that required me to go to lab in order to confirm my logic with the Ta’s and tutors until I figured out that user input starts in the Inverter which then goes into the Adder and finally ends up in the Register. But before I had figured that out, I had thought that Register took in user input which connects to the Inverter then to the Adder and back to the Register, but I learned that the logic is incorrect as it had doubled the values of my inputs because I was already inputting two values in at the same time since I had input a number in the Register which then goes through the Inverter then the Adder and returns it back, doubling it. So if I had input a 2, the 2 would go through the Inverter and the two inputs from the Adder would be from the Inverter and Register, which doubles the value of the original input.

3. For the Six-Bit Register, I added an LED light for one bit to make sure that I was creating the Register correctly and take note of when it lights up when it was suppose to. For the Adder, I also used two LEDs, one for Sum and one for Cout, created my own truth table for one bit only and compared the output of my truth table to the LED lights and check if they worked or not. For the Six-Bit Inverter, I had also used an LED light for the output of the Inverter as well as switches for the inputs, so that way, I can make sure that if it was subtracting, the LED would be the opposite of the input that is not AddSub, and if it was adding, the LED would be the same as the input where 0 is off and 1 is on.

4. When you subtract a larger number from a smaller number, the output would be in a sense, inverted. For example, if you subtract 2 from 1, 1 would be subtracted resulting in a zero, then that zero would be treated as the largest number and subtract the remaining one from it, so if it is a six bit, it would result in 3F or 63. This makes sense because since integers are treated as unsigned, there can never be any negative numbers and zeroes can also be treated as a zero with a carryout. For example, a 2 bit binary 0 can be seen as 00 or 100 where 1 is the carryout. By subtracting the “100” (which is treated as 2 bits) with a 1, the result would be “11”. If you add two numbers that won’t fit in 6 bits, the exact opposite will happen, that is, it will overflow and will result in a carryout. For example, if there were 2 bits of “11” and “10”, and, you add them together, it will overflow and have a carryout of “1” and the result would be “101”, but, because it is treated as 2 bits, the result would be seen as “01” or 1. This same thing applies for any number of bits: if you add two numbers that won’t fit in that bit, then a carryout will be performed, the sum would be turned into a zero, and the sum will keep on adding from zero until it has finished adding the two numbers together.